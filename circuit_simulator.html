<!DOCTYPE html>
<html>
<head>
<title>Circuit Simulator</title>
<style>
html
{ display: grid
; place-items: center
}
body
{ display: grid;
  /*; background: white; */
; grid-template-areas:  "header mediaControls"
                        "boardDesigner legend"
/* ; grid-template-rows:    100px 1fr
; grid-template-columns: 1fr 1fr */
; place-items: center
; grid-gap: 5px
; padding: 0
; margin: 0
; box-sizing: border-box
}
.header
{ grid-area: header
}
.mediaControls
{ grid-area: mediaControls
}
.boardDesigner
{ grid-area: boardDesigner
}
.legend
{ grid-area: legend
}
.cellSquare
{ width: 50px
; height: 50px
; text-align: center
}

</style>
<script>

// == 2024-01-05 Todo status:
// X Single grid board "main" hardcoded to exist at 10x10
// X Legend of node types can be drug onto board
// X Can drag across grid cells to define input chains
// X signalMap is frozen with a handful of hot cells for testing
// X play/pause to enable signal flow
//   Port signal flow logic from Perl proof of concept to HTML/JS
//   Support push and toggle buttons during play
//   Introduce A,B,C,D programmable input nodeTypes
//   Work out system for multiple board grids, chip burning, etc
//   Possibly work out system for beyond-grid circuit design, especially for burnt chips.

// DOM manip cheatsheet
// ; document.createElement(nodeName)
// ; document.body.appendChild(node)
// ; document.createTextNode("text")
// ; node.className = 'whatever';
// ; node.setAttribute('draggable', 'true')
// ; node.onsomekindofeventhandler =
//     (ev) =>
//       { // so what can ev do?
//       }

; // null means mouse recognized as being held down
; // this can also mean "drag interrupted so we're rejecting mouse until it's down again"
; window.mouseDownOver = null

; window.mouseExpiryTimer = null
; window.MASK_INPUT_FROM_ABOVE = 0x1 // Never
; window.MASK_INPUT_FROM_RIGHT = 0x2 // Eat
; window.MASK_INPUT_FROM_BELOW = 0x4 // Shredded
; window.MASK_INPUT_FROM_LEFT  = 0x8 // Wheat
; window.maskOppositeDirections = {}
; maskOppositeDirections[MASK_INPUT_FROM_ABOVE] = MASK_INPUT_FROM_BELOW
; maskOppositeDirections[MASK_INPUT_FROM_RIGHT] = MASK_INPUT_FROM_LEFT
; maskOppositeDirections[MASK_INPUT_FROM_LEFT ] = MASK_INPUT_FROM_RIGHT
; maskOppositeDirections[MASK_INPUT_FROM_BELOW] = MASK_INPUT_FROM_ABOVE

; window.nodeTypeLegend =
  { OR:
    { symbol: '‚à®'
    , description: 'sum of inputs > 0'
    , inputsAllowed: true
    }
  , NOR:
    { symbol: '‚äΩ'
    , description: 'sum of inputs < 1'
    , inputsAllowed: true
    }
  , NAND:
    { symbol: '‚äº'
    , description: 'sum of inputs < 2'
    , inputsAllowed: true
    }
  , XOR:
    { symbol: '‚äª'
    , description: 'sum of inputs == 1'
    , inputsAllowed: true
    }
  , AND:
    { symbol: '‚àß'
    , description: 'sum of inputs > 1'
    , inputsAllowed: true
    }
  , STAR:
    { symbol: '‚≠ê'
    , description: 'Always hot'
    , inputsAllowed: false
    }
  , PUSH:
    { symbol: 'üëá'
    , description: 'Hot while being pressed'
    , inputsAllowed: false
    }
  , TOGGLE:
    { symbol: '‚úî‚ùå'
    , description: 'Pressing toggles between hot/cold'
    , inputsAllowed: false
    }
  , A:
    { symbol: 'A'
    , inputsAllowed: false
    }
  , B:
    { symbol: 'B'
    , inputsAllowed: false
    }
  , C:
    { symbol: 'C'
    , inputsAllowed: false
    }
  , D:
    { symbol: 'D'
    , inputsAllowed: false
    }
  }
; window.nodeTypes = Object.keys(nodeTypeLegend)
; window.nodeTypesSignalInputs = ['A', 'B', 'C', 'D']
; window.USER_INTERFACE_MODE_EDIT = 0
; window.USER_INTERFACE_MODE_SIMULATE = 1
; window.userInterfaceMode = USER_INTERFACE_MODE_EDIT
; window.mediaControlPlayPauseSymbols =
  [ '‚ñ∂' // index 0=USER_INTERFACE_MODE_EDIT, button "play" changes to simulate
  , '‚è∏' // index 0=USER_INTERFACE_MODE_SIMULATE, button "pause" changes to edit
  ]

; window.SIMULATION_HAS_NOT_YET_HAPPENED = -1
; window.steps = SIMULATION_HAS_NOT_YET_HAPPENED
; window.stepDelayInMilliseconds = 500
; window.stepTimerHandle = null
; window.SAFE_TO_SKIP_HASH_CHECK = -1
; window.lastSimulatedBoardHash = SAFE_TO_SKIP_HASH_CHECK

; window.board =
  { width: 10
  , height: 10
  , name: "main"
  , cells:[]
  , DOMnode:null // will get filled in later
  }

; window.EMPTY_SIGNAL_MAP = new Set(['main:5', 'main:6', 'main:44'])
; window.signalMap = EMPTY_SIGNAL_MAP

; function Round(value) { return(Math.floor(value+0.5)) }
; function RealMod(value, base) { return(((value/base) - Math.floor(value/base))*base) }
; function IntMod(value, base) { return(Round(RealMod(value,base))) }

; function initialize()
  { let h1 =
      { nodeName:"h1"
      , nodeAttributes: { class:'header' }
      , nodeChildren:["Circuit Simulator"]
      }
  ; document.body.appendChild(createDomNode(h1))

  ; let table =
      { nodeName:"table"
      , nodeAttributes:
        { cellspacing:"0"
        , class:'boardDesigner'
        , style:
          { 'user-select': 'none'
          }
        }
      , nodeChildren:[]
      }
  ; for(let y=0; y<board.height; y++)
    { let tableRow =
        { nodeName:"tr"
        , nodeChildren:[]
        }
    ; for(let x=0; x<board.width; x++)
      { let tableCellID = ("main:"+ (x+y*board.width))
      ; let tableCell =
          { nodeName:"th"
          , nodeAttributes:
            { style:
              { "background-image":"url(images/spritesheet.png)"
              , "background-size": "1600% 100%"
              , "background-repeat": "no-repeat"
              , "background-position-x": "0px"
              , "background-position-y": "top"
              , "color": "black !important"
              // , filter: "invert(100%)"
              }
            , onmousedown:"tableCellMouseEvent('DOWN', '"+ tableCellID +"')"
            , onmousemove:"tableCellMouseEvent('MOVE', '"+ tableCellID +"')"
            , onmouseenter:"tableCellMouseEvent('ENTER', '"+ tableCellID +"')"
            , onmouseleave:"tableCellMouseEvent('LEAVE', '"+ tableCellID +"')"
            , onmouseup:"tableCellMouseEvent('UP', '"+ tableCellID +"')"
            , ondragover:"event.preventDefault()"
            , ondrop:"boardCellDragRelease(event)"
            , id:tableCellID
            , class:'cellSquare'
            }
          , nodeChildren: ['']
          }
      ; tableRow.nodeChildren.push(tableCell)
      }
    ; table.nodeChildren.push(tableRow)
    }
  ; board.DOMnode = table
  ; document.body.appendChild(createDomNode(table))
  ; for(let cellIndex=0; cellIndex<board.width*board.height; cellIndex++)
    { board.cells[cellIndex] ??=
      { 'nodeType':'OR'
      // { 'nodeType':nodeTypes[IntMod(cellIndex, nodeTypes.length)]
      , 'inputMask':0
      , 'neighborInputAddressSet':new Set()
      }

    ; RenderBoardCell(board, signalMap, cellIndex)
    }
  ; table =
    { nodeName:"table"
    , nodeAttributes:
      { cellspacing:"0"
      , class:'mediaControls'
      , style:
        { 'user-select': 'none'
        }
      }
    , nodeChildren:
      [ { nodeName: 'tr'
        , nodeChildren:
          [ { nodeName: 'th'
            , nodeAttributes:
              { class:'cellSquare'
              }
            , nodeChildren:
              [ { nodeName: 'button'
                , nodeAttributes: { id:'mediaControlRestart' }
                , nodeChildren: '‚á§'
                }
              ]
            }
          , { nodeName: 'th'
            , nodeAttributes:
              { class:'cellSquare'
              }
            , nodeChildren:
              [ { nodeName: 'button'
                , nodeAttributes: { id:'mediaControlStepBack' }
                , nodeChildren: '‚Üê'
                }
              ]
            }
          , { nodeName: 'th'
            , nodeAttributes:
              { class:'cellSquare'
              }
            , nodeChildren:
              [ { nodeName: 'button'
                , nodeAttributes:
                  { id:'mediaControlPlayPause'
                  , onclick:'MediaPlayPause()'
                  }
                , nodeChildren: '‚ñ∂'
                }
              ]
            }
          , { nodeName: 'th'
            , nodeAttributes:
              { class:'cellSquare'
              }
            , nodeChildren:
              [ { nodeName: 'button'
                , nodeAttributes: { id:'mediaControlStepForward' }
                , nodeChildren: '‚Üí'
                }
              ]
            }
          , { nodeName: 'td'
            , nodeAttributes: {id:'stepsDisplayTD'}
            , nodeChildren:
              [ 'Steps: '
              , SIMULATION_HAS_NOT_YET_HAPPENED
              ]
            }
          ]
        }
      ]
    }
  ; document.body.appendChild(createDomNode(table))
  ; table =
    { nodeName:"table"
    , nodeAttributes:
      { cellspacing:"0"
      , class:'legend'
      , style:
        { 'user-select': 'none'
        }
      }
    , nodeChildren:[]
    }
  ; for(let nodeType in nodeTypeLegend)
    { let tableRow =
        { nodeName:"tr"
        , nodeChildren:[]
        }
    ; tableRow.nodeChildren.push
      ( { nodeName: 'th'
        , nodeAttributes:
          { id: 'legend-symbol-'+ nodeType
          , draggable: 'true'
          , ondragstart: 'nodeTypeDragStart(event)'
          , class:'cellSquare'
          }
        , nodeChildren:
          [ { nodeName: 'label'
            , nodeAttributes:
              { for: 'legend-signalTextInput-'+ nodeType
              }
            , nodeChildren: nodeTypeLegend[nodeType].symbol
            }
          ]
        }
      )
    ; if(nodeTypesSignalInputs.includes(nodeType))
      { tableRow.nodeChildren.push
        ( { nodeName: 'td'
          , nodeAttributes:
            { style:
              { padding:'0 10px'
              // , border:'1px solid red'
              }
            , id: 'legend-signalText-'+ nodeType
            , draggable: 'true'
            , ondragstart: 'nodeTypeDragStart(event)'
            , colspan: 2
            }
          , nodeChildren:
            [ { nodeName: 'input'
              , nodeAttributes:
                { type:'text'
                , style: { width:'100%' }
                , id: 'legend-signalTextInput-'+ nodeType
                , name: 'legend-signalTextInput-'+ nodeType
                , oninput:"this.value = this.value.replace(/[^01]/, '')"
                , spellcheck:'false'
                , placeholder:"Repeating binary signal train, ie '000111000111'"
                }
              }
            ]
          }
        )
      }
      else
      { tableRow.nodeChildren.push
        ( { nodeName: 'th'
          , nodeAttributes:
            { id: 'legend-name-'+ nodeType
            , draggable: 'true'
            , ondragstart: 'nodeTypeDragStart(event)'
            }
          , nodeChildren: nodeType
          }
        , { nodeName: 'td'
          , nodeAttributes:
            { style:
              { padding:'0 10px'
              }
            , id: 'legend-description-'+ nodeType
            , draggable: 'true'
            , ondragstart: 'nodeTypeDragStart(event)'
            }
          , nodeChildren: nodeTypeLegend[nodeType].description
          }
        )
      }
    ; table.nodeChildren.push(tableRow)
    }
  ; document.body.appendChild(createDomNode(table))
  }

; function nodeTypeDragStart(event)
  { let nodeType = event.target.id.split('-', 3)[2]
  ; event.dataTransfer.setData("text/plain", 'nodeType:'+ nodeType)
  }

; function boardCellDragRelease(event)
  { event.preventDefault()
  ; let cellIndex = event.target.id.split(':')[1]
  ; let droppedContents = event.dataTransfer.getData('text/plain').split(':', 2)
  ; switch(droppedContents[0])
    { case 'nodeType':
      ; let nodeType = droppedContents[1]
      ; board.cells[cellIndex].nodeType = nodeType
      ; break

      default:
      ; console.log
        ( ( "Board cell #"
          + cellIndex
          + " received an unrecognized drag/drop payload"
          )
        , droppedContents
        )
      ; break
    }
  ; RenderBoardCell(board, signalMap, cellIndex)
  }

// Accepts a node recipe of one of the following two forms:
// * A naked string
// * { nodeName, nodeAttributes, nodeChildren }
// where each node child is either another node.
// naked Strings render to text nodes.
; function createDomNode(nodeRecipe)
  { let node
  ; if(typeof(nodeRecipe)=="object")
    { if(nodeRecipe.hasOwnProperty("nodeName"))
      { nodeRecipe.nodeAttributes ??= {}
      ; nodeRecipe.nodeChildren ??= []
      ; node = document.createElement(nodeRecipe.nodeName)
      ; for(let nodeAttribute in nodeRecipe.nodeAttributes)
        { let nodeAttributeContent = nodeRecipe.nodeAttributes[nodeAttribute]
        ; if(nodeAttribute=="style" && typeof(nodeAttributeContent)=="object")
          { let styleString = ""
            for(let styleKey in nodeAttributeContent)
            { styleString +=
                ( styleKey
                + ": "
                + nodeAttributeContent[styleKey]
                + "; "
                )
            }
            node.setAttribute("style", styleString)
          }
          else
          { node.setAttribute(nodeAttribute, nodeAttributeContent)
          }
        }
      ; for(let nodeChild in nodeRecipe.nodeChildren)
        { node.appendChild(createDomNode(nodeRecipe.nodeChildren[nodeChild]))
        }
      }
      else
      { condole.log
        ( "Error: createDomNode() called with invalid nodeRecipe:"
        , nodeRecipe
        )
      }
    }
    else // assume string
    { node = document.createTextNode(nodeRecipe)
    }
  ; return(node)
  }

; function tableCellMouseEvent(changeType, tableCellID)
  { let currentTableCellIndex = AddressToIndex(tableCellID)
  ; let oldTableCellIndex = AddressToIndex(mouseDownOver)
  ; clearTimeout(mouseExpiryTimer)
  ; mouseExpiryTimer=null

  ; switch(changeType)
    { case 'UP':
      ; mouseDownOver=null
      ; break

      case 'DOWN':
      ; mouseDownOver=tableCellID
      ; break

      case 'MOVE':
      case 'ENTER':
      ; if
        ( mouseDownOver==null
        ||mouseDownOver==tableCellID
        ) { break; } // only track dragging movement between distinct cells

      ; let SetInputFromNeighbor = (bitmask) =>
        { let nodeType = board.cells[currentTableCellIndex].nodeType
        ; if(nodeTypeLegend[nodeType].inputsAllowed)
          { board.cells[currentTableCellIndex].neighborInputAddressSet.add(mouseDownOver)
          ; board.cells[currentTableCellIndex].inputMask |= bitmask
          ; board.cells[oldTableCellIndex].neighborInputAddressSet.delete(tableCellID)
          ; board.cells[oldTableCellIndex].inputMask &= ~maskOppositeDirections[bitmask]
          ; RenderBoardCell(board, signalMap, oldTableCellIndex)
          ; RenderBoardCell(board, signalMap, currentTableCellIndex)
          }
        ; mouseDownOver=tableCellID
        }
      ; if(oldTableCellIndex + board.width == currentTableCellIndex)
        { SetInputFromNeighbor(MASK_INPUT_FROM_ABOVE)
        }
        else if
          ( oldTableCellIndex - 1 == currentTableCellIndex
          // current cell not already on right edge
          &&currentTableCellIndex%board.width<board.width-1
          )
        { SetInputFromNeighbor(MASK_INPUT_FROM_RIGHT)
        }
        else if(oldTableCellIndex - board.width == currentTableCellIndex)
        { SetInputFromNeighbor(MASK_INPUT_FROM_BELOW)
        }
        else if
          ( oldTableCellIndex + 1 == currentTableCellIndex
          // current cell not already on left edge
          &&currentTableCellIndex%board.width>0
          )
        { SetInputFromNeighbor(MASK_INPUT_FROM_LEFT)
        }
        else
        { mouseDownOver=null // moved to non-neighbor: drag break
        ; break
        }
      ; break

      // This is to protect against mouse focus changes
      case 'LEAVE':
      ; mouseExpiryTimer =
          setTimeout
          ( () => { tableCellMouseEvent('UP', tableCellID) }
          , 500
          )
      ; break

      default:
      ; console.log("Unrecognized changeType in tableCellMouseEvent():", changeType)
      ; break
    }
  }

; function RenderBoard(board, signalMap)
  { const oneDSize = board.width*board.height
  ; for(let cellIndex=0; cellIndex<oneDSize; cellIndex++)
    { RenderBoardCell(board, signalMap, cellIndex)
    }
  }

; function RenderBoardCell(board, signalMap, cellIndex)
  { let cellAddress = board.name +':'+ cellIndex
  ; let node = document.getElementById(cellAddress)
  ; let cell = board.cells[cellIndex]
  ; let hot = signalMap.has(board.name +':'+ cellIndex)
  ; let symbol =
      ( cell.nodeType == 'OR'
      ? ''
      : ( hot
        ? Array.from(nodeTypeLegend[cell.nodeType].symbol)[0] //first codepoint
        : Array.from(nodeTypeLegend[cell.nodeType].symbol).slice(-1)[0] //last codepoint
        )
      )

  ; if(!nodeTypeLegend[cell.nodeType].inputsAllowed)
    { board.cells[cellIndex].inputMask = 0
    }

  ; let backgroundStyles =
    { backgroundImage:[]
    , backgroundPositionX:[]
    , backgroundPositionY:[]
    , backgroundSize:[]
    }
  ; if(hot)
    { backgroundStyles.backgroundImage.push('url(images/hot%20glow.png)')
    ; backgroundStyles.backgroundPositionX.push('49.0566%')
    ; backgroundStyles.backgroundPositionY.push('49.0566%')
    ; backgroundStyles.backgroundSize.push('47% 47%')
    }
  ; backgroundStyles.backgroundImage.push('url(images/spritesheet.png)')
  ; backgroundStyles.backgroundSize.push('1600% 100%')
  ; backgroundStyles.backgroundPositionX.push
    ( '+'
    + (board.cells[cellIndex].inputMask*(100/15))
    + '%'
    )
  ; backgroundStyles.backgroundPositionY.push('0')
    for(let backgroundStyleName in backgroundStyles)
    { node.style[backgroundStyleName] =
        backgroundStyles[backgroundStyleName].join(', ')
    }
  ; node.firstChild.data = symbol
  }

; function AddressToIndex(address)
  { if(typeof(address)!="string") { return -1; }
  ; let addressParts = address.split(':',2)

  ; // only handle "main" board for the time being
  ; if(addressParts[0]!='main') { return -1; }

  ; // invalid unless second part is a plainclothes non-negative integer
  ; if(!/^\d+$/.test(addressParts[1])) { return -1; }

  ; return(+addressParts[1])
  }

function MediaPlayPause()
{ clearInterval(stepTimerHandle)
; userInterfaceMode = 1-userInterfaceMode // toggles between 0=edit and 1=simulate
; document.getElementById('mediaControlPlayPause').firstChild.data =
    mediaControlPlayPauseSymbols[userInterfaceMode]

  if(userInterfaceMode==USER_INTERFACE_MODE_SIMULATE)
  { // run first step immediately, and let that function handle scheduling
    // later steps
  ; SimulateStep()
  }
  else
  { if(steps!=SIMULATION_HAS_NOT_YET_HAPPENED)
    { lastSimulatedBoardHash = cyrb53(JSON.stringify(board))
    }
  }
}

function SimulateStep()
{ if(userInterfaceMode!=USER_INTERFACE_MODE_SIMULATE)
  { clearInterval(stepTimerHandle)
  }

; if(steps == SIMULATION_HAS_NOT_YET_HAPPENED)
  { signalMap = EMPTY_SIGNAL_MAP
  ; lastSimulatedBoardHash = SAFE_TO_SKIP_HASH_CHECK
  }

; if
  ( lastSimulatedBoardHash == SAFE_TO_SKIP_HASH_CHECK
  ||lastSimulatedBoardHash == cyrb53(JSON.stringify(board)) // no edits since last sim step
  )
  { steps++
  }
; UpdateStepsDisplay()
; lastSimulatedBoardHash = SAFE_TO_SKIP_HASH_CHECK

// TBI: Actually perform a simulation step
; RenderBoard(board, signalMap)

  // This `if` clause helps ensure that manual press of step forward in edit mode
  // does not wind up repeating
; if(userInterfaceMode==USER_INTERFACE_MODE_SIMULATE)
  { clearInterval(stepTimerHandle)
  ; stepTimerHandle = setInterval(SimulateStep, stepDelayInMilliseconds)
  }
}

function CalculateSignalMap(network, oldSignalMap, step)
{ let newSignalMap = new Set()
; return(newSignalMap)
}

function UpdateStepsDisplay()
{ document.getElementById('stepsDisplayTD').childNodes[1].data = steps
}

// simple and fast 53-bit string hashing function released CC0 here:
// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
function cyrb53(stringToHash, seed=0)
{ let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed
; for(let i = 0, ch; i < stringToHash.length; i++)
  { ch = stringToHash.charCodeAt(i)
  ; h1 = Math.imul(h1 ^ ch, 2654435761)
  ; h2 = Math.imul(h2 ^ ch, 1597334677)
  }
; h1  = Math.imul(h1 ^ (h1 >>> 16), 2246822507)
; h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)
; h2  = Math.imul(h2 ^ (h2 >>> 16), 2246822507)
; h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)

; return 4294967296 * (2097151 & h2) + (h1 >>> 0)
}

</script>
</head>
<body onload="initialize()"></body>
</html>
